<?php

namespace AppBundle\Repository;

use Doctrine\ODM\MongoDB\DocumentRepository;
use AppBundle\Manager\PassageManager;
/**
 * EtablissementRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
use MongoDate as MongoDate;
use AppBundle\Manager\EtablissementManager;
use AppBundle\Document\Contrat;

class PassageRepository extends DocumentRepository {

    public function findAllPlanifieByPeriodeAndIdentifiantTechnicien($startDate, $endDate, $technicien, $onlyNonImprime = false) {
        $mongoStartDate = new MongoDate(strtotime($startDate . " 00:00:00"));
        $mongoEndDate = new MongoDate(strtotime($endDate . " 23:59:59"));
        $query = $this->createQueryBuilder('Passage')
                ->field('dateDebut')->gte($mongoStartDate)
                ->field('dateDebut')->lte($mongoEndDate)
                ->field('dateFin')->gte($mongoStartDate)
                ->field('techniciens')->equals($technicien->getId())
                ->sort('dateDebut', 'asc');
        if ($onlyNonImprime) {
        	$query->field('imprime')->equals(false);
        }
        $query = $query->getQuery();

        return $query->execute();
    }

    public function findAllPlanifieByPeriode($startDate, $endDate, $onlyNonImprime = false) {
        $mongoStartDate = new MongoDate(strtotime($startDate));
        $mongoEndDate = new MongoDate(strtotime($endDate));
        $query = $this->createQueryBuilder('Passage')
                ->field('dateDebut')->gte($mongoStartDate)
                ->field('dateDebut')->lte($mongoEndDate)
                ->field('dateFin')->gte($mongoStartDate)
                ->sort('technicien', 'desc')
                ->sort('dateDebut', 'asc');
        if ($onlyNonImprime) {
        	$query->field('imprime')->equals(false);
        }
        $query = $query->getQuery();
        return $query->execute();
    }

    public function findHistoriqueByEtablissementAndPrestationsAndNumeroContrat(Contrat $contrat, $etablissement, $prestations = array(), $limit = 2) {
        $passagesHistorique = array();

        $contratsNumArchive = $this->dm->getRepository('AppBundle:Contrat')->findByNumeroArchive($contrat->getNumeroArchive());
        $contratsNumArchiveArray = array();
        foreach ($contratsNumArchive as $contratNumArchive) {
            $contratsNumArchiveArray[$contratNumArchive->getId()] = $contratNumArchive->getId();
        }
        foreach ($prestations as $prestation) {
            $passages = array();
            foreach ($contratsNumArchiveArray as $idContrat) {
                $passages = array_merge($passages, $this->findBy(array('contrat' => $idContrat, 'etablissement' => $etablissement->getId(), 'statut' => PassageManager::STATUT_REALISE, 'prestations.identifiant' => $prestation->getIdentifiant()), array('dateDebut' => 'DESC'), $limit));
                foreach ($passages as $passage) {
                    $passagesHistorique[$passage->getDateDebut()->format('YmdHi') . "_" . $passage->getId()] = $passage;
                }
            }
        }

        krsort($passagesHistorique);

        $passagesHistorique = array_slice($passagesHistorique, 0, 2);

        return $passagesHistorique;
    }

    public function findOneByIdentifiantPassage($identifiantPassage) {

        return $this->findOneBy(
                        array('id' => 'PASSAGE-' . $identifiantPassage));
    }

    public function findOneByIdentifiantEtablissementAndIdentifiantPassage($identifiantEtb, $identifiantPassage) {

        return $this->findOneBy(
                        array('id' => 'PASSAGE-' . $identifiantEtb . '-' . $identifiantPassage));
    }

    public function findByEtablissementAndCreateAt($etablissementIdentifiant, $createAt) {
        return $this->findBy(
                        array('etablissementIdentifiant' => $etablissementIdentifiant, 'createAt' => $createAt));
    }

    public function findPassagesForEtablissement($etablissementIdentifiant) {
        $query = $this->createQueryBuilder('Passage')
                ->field('etablissementIdentifiant')->equals($etablissementIdentifiant)
                ->sort('datePrevision', 'desc')
                ->getQuery();
        return$query->execute();
    }

    public function findPassagesForEtablissementSortedByContrat($etablissementIdentifiant) {
        $query = $this->createQueryBuilder('Passage')
                ->field('etablissementIdentifiant')->equals($etablissementIdentifiant)
                ->sort('contratId', 'desc')->sort('dateCreation', 'desc')
                ->getQuery();
        return $query->execute();
    }

    public function findTechniciens() {
        $techniciens = array();
        $date = new \DateTime();
        $mongoEndDate = new MongoDate(strtotime($date->format('Y-m-d')));
        $date->modify('-2 month');
        $mongoStartDate = new MongoDate(strtotime($date->format('Y-m-d')));
        $query = $this->createQueryBuilder('Passage')
                ->field('dateFin')->gte($mongoStartDate)
                ->field('dateFin')->lte($mongoEndDate)
                ->group(array('technicien' => 1), array('count' => 0))
                ->reduce('function (obj, prev) { prev.count++; }')
                ->getQuery();
        $result = $query->execute();

        if (count($result)) {
            foreach ($result as $item) {
                $techniciens[$item['technicien']] = $item['technicien'];
            }
        }

        ksort($techniciens);

        return $techniciens;
    }

    public function findToPlan($secteur = EtablissementManager::SECTEUR_PARIS) {
        $dpts = EtablissementManager::$secteurs_departements[EtablissementManager::SECTEUR_SEINE_ET_MARNE];
        $date = new \DateTime();
        $twoMonth = clone $date;
        $twoMonth->modify("last day of next month");

        $mongoEndDate = new MongoDate(strtotime($twoMonth->format('Y-m-d')));

        $q = $this->createQueryBuilder();

        $q->field('statut')->equals(PassageManager::STATUT_A_PLANIFIER)
                ->field('datePrevision')->lte($mongoEndDate);
        $regex = '';
        $dptReg = '';
        foreach ($dpts as $i => $dpt) {
            $dptReg .= $dpt;
            if ($i < count($dpts) - 1) {
                $dptReg .= '|';
            }
        }
            $regex .= '/^(' . $dptReg . ')/i';
        if ($secteur == EtablissementManager::SECTEUR_PARIS) {
           $q->addAnd($q->expr()->field('etablissementInfos.adresse.codePostal')->operator('$not', new \MongoRegex($regex)));
        } else {
           $q->addAnd($q->expr()->field('etablissementInfos.adresse.codePostal')->equals(new \MongoRegex($regex)));
        }
        $query = $q->sort('datePrevision', 'asc')->getQuery();

        return $query->execute();
    }

    public function getNbPassagesToPlanPerMonth($secteur = EtablissementManager::SECTEUR_PARIS) {
        $passages = $this->findToPlan($secteur);
        $result = array();
        foreach ($passages as $passage) {
            $moisAnnee = $passage->getDatePrevision()->format('Ym');
            if (!array_key_exists($moisAnnee, $result)) {
                $result[$moisAnnee] = new \stdClass();
                $result[$moisAnnee]->nb = 0;
                $result[$moisAnnee]->date = $passage->getDatePrevision();
            }
            $result[$moisAnnee]->nb = $result[$moisAnnee]->nb + 1;
        }
        return $result;
    }

    public function countPassagesByTechnicien($compte) {

        return $this->createQueryBuilder()
                        ->field('techniciens')->equals($compte->getId())
                        ->getQuery()->execute()->count();
    }

    public function findAllNettoyages() {
        $request = $this->createQueryBuilder()
                ->distinct('nettoyages')
                ->hydrate(false)
                ->getQuery()
                ->execute();
        return $request->toArray();
    }

    public function findAllApplications() {
        return PassageManager::$applications;
    }

}
